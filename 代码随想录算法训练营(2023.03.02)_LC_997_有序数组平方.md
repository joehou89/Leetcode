### 1.今日题目997. 有序数组平方  

### 2.自己看到题目的第一想法  
因为题目上已经提示了一下，双指针算法，在草纸上划了一下，首先将所有的数值平方，双指针就是两根指针分别指向头和尾，进行比较，如果大于，就怎么怎么样，如果小于，就怎么怎么样，没问题，就这么写。  
  
### 3.自己实现过程中遇到哪些困难    
发现写着写着不对了，原因是比较了一次还可以，但是后面就比不下去了，比如:  
```c  
原数组元素：-4,-1,0,3,10 
平方后：16, 1, 0,9,100
首先16和100比较，小于，不动，然后该怎么移动呢？是头指针++,还是尾指针--呢？不好说了。所以按照这个猜想，应该是双for 选择排序法才对，大数沉底，然后继续第二轮循环.但是这明显不符合O(n).  
  
```  
  
### 4.看完代码随想录之后的想法  
看了一下随想录的题解，噢，直接用了一个std::sort()快速排序函数， 这是暴力解法.代码如下:  
```c  
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
      for (int i = 0; i< nums.size(); i++) {
          nums[i] *= nums[i];
      }
      std::sort(nums.begin(), nums.end());
      return nums;
    }
};
```  
这个时间复杂度为O(n+nlogn)
  
既然提到了双指针法，说明两根指针一定是可行的，但是要怎么做呢？看了之后，发现我忽略了题干，人家说是非递减顺序的数组，即数组元素已经是排序了的，平方后，最大最小只可能在两端，不可能在中间，
原因是负数也可能变成最大，所以直接比较头节点和尾节点的大小即可.  
```c  
i = 0;j = max - 1;
if (nums[i] < nums[j]) {
  j--;
} else {
  交换两个;
  i++;
}
```  
只不过题目用了一个新的数组，这里我想沿用旧数组试试.但是尝试过后， 我明白我错误的地方了，必须要要使用一个新的数组来承接排序后的元素，原数组上无法进行双指针的排序，原因是当头指针>尾指针这种
情况后，一旦发生交换， 有可能会导致大数排在了前缀，而此时i++，所以前面的大数就不能再与后面的数进行比较了。而把排序后的数放在一个新的数组就可以解决这个问题.  
  
### 5.今日收获  
对于双指针算法加深了一些理解，像这道题，其实基本上知道了算法思路，稍加一点思考就可以做出来，但是还是欠了一些，就以为双指针法不能解。

### 6.今日学习的文章链接、视频链接  
https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html  
  
