### 1.思路  
题目是要将一棵bst树转换为一棵累加树，这道题如果是挨个遍历，时间复杂度肯定是超的，所以肯定不能这么写。但是似乎又想不到更好的方法。看了一下随想录的算法分析，其实
还是没读懂题干和bst树的特点。BST(二插搜索树)是一棵有序树，比如如下:  
```c  
                5
             /     \
           3        11 
         /   \    /    \
       2      4  7      17     
```  
只看BST树很难看出其中的特点，我们耳熟能详的无非就是:  
```c  
1.左子树的数值小于中间节点数值;  
2.右子树的数值大于中间节点数值;
```  
但是很难把它和有序数组联系起来，这个是本题解题的关键.有序数组的累加就会方便很多，从后往前依次相加就是每一个节点自身的累加值了，比如:  
```c  
有序数组: {2,3,4,5,7,11,17}
题目要求累加的原则是，每一个节点上的数值加上不小于自己(即自己和大于自己)，所以最后一个就是17自己，
17->17
11--> 11 + 17 --> 28
7-> 7 + 28 --> 35
5->5 + 35 --> 40
4-> 4 + 40 --> 44
3 -> 3 + 44 --> 47
2 -> 2 + 47 --> 49

累加二叉树就变为了:  
{49, 47, 44, 40, 35, 28, 17}
```  
  
以上便是利用BST树的有序特点转换成有序数组的思想来计算累加的效果。  
但是实际在代码实现过程中，还是要按照树的遍历写法，其实二叉树这块的算法通过看随想录也得出一些规律，就是几乎所有的二叉树的题目都是递归和迭代来实现。  
递归算法解二叉树这是因为二叉树的特点，遍历；而迭代之所以也能够解决二叉树中的问题是因为迭代可以使用一个中间容器适配器队列或者栈来模拟整个过程.    
这里先看一种算法递归算法，这里随想录给出的是一种反中序遍历算法，中序是左-中-右，反中序递归算法就是右-中-左，还是先写出递归三原则:  
```c  
函数入参和返回值题目已经给出了:  
void convertBST(TreeNode* root)
入参是原二叉树的头节点,没有返回值;

递归遍历结束的条件是当判断到一个节点为空:  if (root == NULL) return;

单次遍历逻辑:
看有序数组的累加过程是从尾巴上的数值依次往前加，所以要定义一个临时变量，需要记录下来每一个节点当时的累加和，sum;
TreeNode* convertBST(TreeNode* root)
{
  if (root == NULL) return;
  convertBST(root->right);
  root->val += pre_sum;//更新自己的值
  pre_sum = root->val;//将当前最新的累加和赋值给pre_sum变量，便于下次遍历到的节点值相加
  convertBST(root->left);
}

```  
  







