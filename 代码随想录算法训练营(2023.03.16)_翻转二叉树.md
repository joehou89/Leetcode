### 1.题目思考  
翻转二叉树就是给这棵树做一个镜像，左边的换到右边，右边的换到左边。本题的意图中的二叉树，猜测应该是一颗满二叉树，所以采用某种遍历算法进行遍历，然后翻转左右子节点即可。  
我的算法很简单:  
1.既然要用上递归算法，首先就要先遍历一把，那我们用前序遍历，中左右。比如遍历前是这样:  
```c  
             --> 4
               /   \
              2     7
            /   \ /   \
           1    36     9
```  
2.前序遍历先到4，判断左子树和右子树是否存在，如果存在，则移到左子树2，如下图所示:  
```c  
                 4
               /   \
        --->  2     7
            /   \ /   \
           1    36     9
```  
3.继续判断左子树和右子树是否存在，发现存在，则移动到左子树1，如下图所示:  
```c  
                 4
               /   \
              2     7
            /   \ /   \
   --->    1    36     9

```  
4.此时再判断1是否有左子树和右子树是否存在，发现此时没有了，从新移动回2，然后交换节点2的左右子节点:  
```c  
                 4
               /   \
     --->     2     7
            /   \ /   \
           3    16     9

```  
5.此时再回朔到节点4，并交换左右子树，如下图所示:  
```c  
       --->      4
               /   \
              7     2
            /   \ /   \
           6    93     1
```  
这里...发现不对了，出问题了.说明算法是行不通的。从遍历一颗树的最小支进行交换左右子节点，再回朔到最大支进行交换左右子节点的方法是不行的。  
  
再尝试从顶端节点依次交换到最后的底层节点是否可行呢？，推演一下:  
```c  
             --> 4
               /   \
              2     7
            /   \ /   \
           1    36     9
```  
1.此时判断是否存在左子树和右子树，发现都存在，则交换两端，如下图所示:  
```c  
             --> 4
               /   \
              7     2
            /   \ /   \
           6    91     3
```  
2.然后选择当前节点为左子节点，如下图所示：  
```c  
                 4
               /   \
      --->    7     2
            /   \ /   \
           6    91     3
```  
3.判断7节点是否包含左子节点和右子节点，发现是有的，交换:  
```c  
                 4
               /   \
       --->   7     2
            /   \ /   \
           9    61     3
```  
4.此时节点移动到9节点，判断一下该节点是否有左子节点和右子节点:  
```c  
                 4
               /   \
              7     2
            /   \ /   \
    --->   9    61     3
```  
此时发现9节点是没有孩子节点的，于是直接退回.  
5.再回退节点到2，判断2是否有左子节点和右子节点，发现是有的，交换：  
```c  
                 4
               /   \
              7     2  <---
            /   \ /   \
           9    63     1
```  
推演下来似乎没有问题，是可行的。  
  
代码如下(随想录给出的)  
```c  
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return root;
        swap(root->left, root->right);  // 中
        invertTree(root->left);         // 左
        invertTree(root->right);        // 右
        return root;
    }
};
```  

