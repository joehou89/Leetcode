### 1.今日题目lc.28  
字符串匹配问题、比如文本串里是否有模式串，返回第一次出现的下标、文本串中出现过几次模式串等问题，这些都是kmp算法经典的应用场景。  
  
### 2.自己看到题目的第一想法  
去年看随想录，kmp算法专门看过，今天再看发现自己基本上忘的一干二净了，只知道有一个前缀表(next数组)，我觉得一方面跟这个算法的理解有一定的关系，说明还是没有搞懂
前缀表的意义，还有一方面是当时没有做总结梳理，已经隔了这么久，不忘才怪。今天重新捡起来，我们先看下随想录书里给出的例子：  
```c  
文本串: a a b a a b a a f a
模式串: a a b a a f
```  
  
先尝试从正面解析一下:  
```c  
文本串: a a b a a b a a f a
       |
       i
模式串: a a b a a f
       |
       j

假设文本串和模式串同时遍历，直到找到不相等的字符为止，就像这样:  
文本串: a a b a a b a a f a
                 |
                 i
模式串: a a b a a f
                 |
                 j
```  
那么下一步该如何做呢？此时时间复杂度是O(n)，假设我们用笨方法，此时发现模式串和文本串已经不匹配了但是文本串还没有遍历完全，则模式串、文本串就要从下一个字符
开始遍历，就像这样:
```c  
文本串: a a b a a b a a f a
         |
         i
模式串: a a b a a f
       |
       j
```  
...  
直到什么情况呢，如下这样:  
```c  
文本串: a a b a a b a a f a
             |
             i
模式串: a a b a a f
       |
       j
```  
此时再遍历发现文本串里遍历出了模式串的字符内容。但是这个时间复杂度是o(n * m)，这个在力扣编译机上肯定是不过的。  
就要想一个办法能够记住文本串里曾经出现过模式串匹配部分在文本串的位置或者下标。只要记住这个下标，直接返回，就不要每次都要从头开始遍历了， 这个记录内容的东西
应该就是随想录说的前缀表或者next数组吧.还是回到刚才第一个出现不匹配的场景:  
```c  
文本串: a a b a a b a a f a
                 |
                 i
模式串: a a b a a f
                 |
                 j
```  
优化的想法就是此时发现b和f不相等了，文本串的i指针就要回退，往前指，我们希望是能够指回到匹配字符串aab的a字符的下标，但是文本串中有两处aab aab，该指向第一处
还是第二处？既然第一处的aab已经不匹配了，肯定从就近能够匹配的开始，所以这里是第二处aab，就像下面这样:  
```c  
文本串: a a b a a b a a f a
             |
             i
模式串: a a b a a f
                 |
                 j
```  
此时将模式串的指针j从新指回原处，如下:  
```c  
文本串: a a b a a b a a f a
             |
             i
模式串: a a b a a f
       |
       j
```  
然后再从头开始遍历，发现就完美匹配了。此时返回文本串中a的下标即可.  
现在问题就是前缀表要怎么构建？这块其实是可以多思考一下的，但时间有限，直接看随想录吧。看过之后，还是有一点概况，发现类似kmp算法所有的算法原理，只要你想不到
这种方法，后面一定会想不出来，原因很简单，你想不到那个点子上，它已经超出了你的认知范围，只能认了。但是学习和进步的意义不就在此么？.  
当研究透大彻大悟后，胸中有丘壑了，再来看类似的问题或者相似的问题的时候，那个时候，脑子里可能会有一种想法，我记得有一条路可以行得通，kmp算法的原理可以尝试
解决吗...  
好，我们回来前缀表的计算，刚开始我也以为前缀表是不是记录的就是文本串和模式串遍历过的内容呢，演算了一下，发现并不是，根本起不到作用。它是记录什么呢？  
上面我的演算过程有一个问题，看如下:  
```c  
文本串: a a b a a b a a f a
                 |
                 i
模式串: a a b a a f
                 |
                 j
```  
此时当文本串和模式串第一次出现不匹配时，文本串的i位置是不变的，只需要修改模式串的下标j即可，这就是前缀表的作用。用随想录的话说，  
"前缀表的任务就是当前位置匹配失败后，找到之前已经匹配的位置再重新匹配，这也意味着某个字符失配时，前缀表告诉我们下一步匹配时模式串应该跳到哪个位置"  
从而和文本串继续往后遍历，如下图所示:  
```c  
文本串: a a b a a b a a f a
                 |
                 i (注意：i的下标不动)
模式串: a a b a a f
           |
           j
```  
那么前缀表记录的是什么东西呢？答案：记录的是最初相同前后缀的长度信息。  
什么是前缀，什么是后缀？  
前缀是不包含最后一个字符的所有以第一个字符开头的连续子字符串；  
后缀是不包含第一个字符的所有以最后一个字符结尾的连续子字符串；  
例如：aaa的最长相同前后缀的长度为2.  
回来题目的字符串:  
```c  
下标  : 0 1 2 3 4 5
模式串: a a b a a f
```  





### 3.自己实现过程中遇到哪些困难  
### 4.看完代码随想录之后的想法  
### 5.今日收获  
### 6.今日学习的文章链接、视频链接  
https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC  
  
  


